"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Vector Similarity Demo
 * The test functionality and Query testing
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@hyper-space.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HyperspaceApi = exports.HyperspaceApiFactory = exports.HyperspaceApiFp = exports.HyperspaceApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * HyperspaceApi - axios parameter creator
 * @export
 */
const HyperspaceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add a new batch to the collection
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatch: (collectionName, document, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('addBatch', 'collectionName', collectionName);
            // verify required parameter 'document' is not null or undefined
            (0, common_1.assertParamExists)('addBatch', 'document', document);
            const localVarPath = `/api/v1/{collectionName}/batch`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = document;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a new document to the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument: (collectionName, document, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('addDocument', 'collectionName', collectionName);
            // verify required parameter 'document' is not null or undefined
            (0, common_1.assertParamExists)('addDocument', 'document', document);
            const localVarPath = `/api/v1/{collectionName}/document/add`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = document;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Process bulk operations on documents
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulk: (collectionName, document, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('bulk', 'collectionName', collectionName);
            // verify required parameter 'document' is not null or undefined
            (0, common_1.assertParamExists)('bulk', 'document', document);
            const localVarPath = `/api/v1/{collectionName}/bulk`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = document;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Clear all collection vectors
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCollection: (collectionName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('clearCollection', 'collectionName', collectionName);
            const localVarPath = `/api/v1/{collectionName}/delete`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsInfo: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/collectionsInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Commit
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: (collectionName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('commit', 'collectionName', collectionName);
            const localVarPath = `/api/v1/{collectionName}/commit`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new collection
         * @param {string} collectionName
         * @param {any} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: (collectionName, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('createCollection', 'collectionName', collectionName);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createCollection', 'body', body);
            const localVarPath = `/api/v1/collection/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes documents that match the specified query.
         * @param {string} collectionName
         * @param {DeleteByQueryRequest} deleteByQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByQuery: (collectionName, deleteByQueryRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('deleteByQuery', 'collectionName', collectionName);
            // verify required parameter 'deleteByQueryRequest' is not null or undefined
            (0, common_1.assertParamExists)('deleteByQuery', 'deleteByQueryRequest', deleteByQueryRequest);
            const localVarPath = `/api/v1/{collectionName}/delete_by_query`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteByQueryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: (collectionName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('deleteCollection', 'collectionName', collectionName);
            const localVarPath = `/api/v1/collection/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: (collectionName, documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('deleteDocument', 'collectionName', collectionName);
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('deleteDocument', 'documentId', documentId);
            const localVarPath = `/api/v1/{collectionName}/document/delete`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName
         * @param {any} body
         * @param {string} [_options]
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dslSearch: (collectionName, body, _options, source, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('dslSearch', 'collectionName', collectionName);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('dslSearch', 'body', body);
            const localVarPath = `/api/v1/{collectionName}/dsl_search`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (_options !== undefined) {
                localVarQueryParameter['options'] = _options;
            }
            if (source !== undefined) {
                localVarQueryParameter['_source'] = source;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Find document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {boolean} [metadataOnly]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: (collectionName, documentId, metadataOnly, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('getDocument', 'collectionName', collectionName);
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('getDocument', 'documentId', documentId);
            const localVarPath = `/api/v1/{collectionName}/document/get`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }
            if (metadataOnly !== undefined) {
                localVarQueryParameter['metadata_only'] = metadataOnly;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get schema of collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: (collectionName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('getSchema', 'collectionName', collectionName);
            const localVarPath = `/api/v1/{collectionName}/schema`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Login
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: (loginDto, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'loginDto' is not null or undefined
            (0, common_1.assertParamExists)('login', 'loginDto', loginDto);
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(loginDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Run multiple DSL queries in a single request
         * @param {string} collectionName
         * @param {any} body
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        msearch: (collectionName, body, source, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('msearch', 'collectionName', collectionName);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('msearch', 'body', body);
            const localVarPath = `/api/v1/{collectionName}/msearch`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (source !== undefined) {
                localVarQueryParameter['_source'] = source;
            }
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/reset_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update documents that match a query using a script
         * @param {string} collectionName
         * @param {UpdateByQuery} updateByQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByQuery: (collectionName, updateByQuery, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('updateByQuery', 'collectionName', collectionName);
            // verify required parameter 'updateByQuery' is not null or undefined
            (0, common_1.assertParamExists)('updateByQuery', 'updateByQuery', updateByQuery);
            const localVarPath = `/api/v1/{collectionName}/update_by_query`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateByQuery, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update document by Id in the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {boolean} [partialUpdate]
         * @param {boolean} [docAsUpsert]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument: (collectionName, document, partialUpdate, docAsUpsert, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionName' is not null or undefined
            (0, common_1.assertParamExists)('updateDocument', 'collectionName', collectionName);
            // verify required parameter 'document' is not null or undefined
            (0, common_1.assertParamExists)('updateDocument', 'document', document);
            const localVarPath = `/api/v1/{collectionName}/document/update`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (partialUpdate !== undefined) {
                localVarQueryParameter['partialUpdate'] = partialUpdate;
            }
            if (docAsUpsert !== undefined) {
                localVarQueryParameter['docAsUpsert'] = docAsUpsert;
            }
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = document;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.HyperspaceApiAxiosParamCreator = HyperspaceApiAxiosParamCreator;
/**
 * HyperspaceApi - functional programming interface
 * @export
 */
const HyperspaceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.HyperspaceApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add a new batch to the collection
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatch(collectionName, document, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addBatch(collectionName, document, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.addBatch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Add a new document to the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(collectionName, document, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addDocument(collectionName, document, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.addDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Process bulk operations on documents
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulk(collectionName, document, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.bulk(collectionName, document, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.bulk']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Clear all collection vectors
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCollection(collectionName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.clearCollection(collectionName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.clearCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsInfo(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.collectionsInfo(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.collectionsInfo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Commit
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(collectionName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commit(collectionName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.commit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a new collection
         * @param {string} collectionName
         * @param {any} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(collectionName, body, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCollection(collectionName, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.createCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deletes documents that match the specified query.
         * @param {string} collectionName
         * @param {DeleteByQueryRequest} deleteByQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByQuery(collectionName, deleteByQueryRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteByQuery(collectionName, deleteByQueryRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.deleteByQuery']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCollection(collectionName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.deleteCollection']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(collectionName, documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDocument(collectionName, documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.deleteDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName
         * @param {any} body
         * @param {string} [_options]
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dslSearch(collectionName, body, _options, source, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.dslSearch(collectionName, body, _options, source, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.dslSearch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Find document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {boolean} [metadataOnly]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(collectionName, documentId, metadataOnly, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDocument(collectionName, documentId, metadataOnly, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.getDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get schema of collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(collectionName, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSchema(collectionName, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.getSchema']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Login
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.login(loginDto, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.login']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Run multiple DSL queries in a single request
         * @param {string} collectionName
         * @param {any} body
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        msearch(collectionName, body, source, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.msearch(collectionName, body, source, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.msearch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetPassword(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.resetPassword']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update documents that match a query using a script
         * @param {string} collectionName
         * @param {UpdateByQuery} updateByQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByQuery(collectionName, updateByQuery, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateByQuery(collectionName, updateByQuery, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.updateByQuery']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update document by Id in the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {boolean} [partialUpdate]
         * @param {boolean} [docAsUpsert]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(collectionName, document, partialUpdate, docAsUpsert, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDocument(collectionName, document, partialUpdate, docAsUpsert, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HyperspaceApi.updateDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.HyperspaceApiFp = HyperspaceApiFp;
/**
 * HyperspaceApi - factory interface
 * @export
 */
const HyperspaceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.HyperspaceApiFp)(configuration);
    return {
        /**
         *
         * @summary Add a new batch to the collection
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatch(collectionName, document, options) {
            return localVarFp.addBatch(collectionName, document, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a new document to the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(collectionName, document, options) {
            return localVarFp.addDocument(collectionName, document, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Process bulk operations on documents
         * @param {string} collectionName
         * @param {Array<Document>} document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulk(collectionName, document, options) {
            return localVarFp.bulk(collectionName, document, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Clear all collection vectors
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCollection(collectionName, options) {
            return localVarFp.clearCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsInfo(options) {
            return localVarFp.collectionsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Commit
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(collectionName, options) {
            return localVarFp.commit(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new collection
         * @param {string} collectionName
         * @param {any} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(collectionName, body, options) {
            return localVarFp.createCollection(collectionName, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes documents that match the specified query.
         * @param {string} collectionName
         * @param {DeleteByQueryRequest} deleteByQueryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByQuery(collectionName, deleteByQueryRequest, options) {
            return localVarFp.deleteByQuery(collectionName, deleteByQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName, options) {
            return localVarFp.deleteCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(collectionName, documentId, options) {
            return localVarFp.deleteDocument(collectionName, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName
         * @param {any} body
         * @param {string} [_options]
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dslSearch(collectionName, body, _options, source, options) {
            return localVarFp.dslSearch(collectionName, body, _options, source, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Find document by Id
         * @param {string} collectionName
         * @param {string} documentId
         * @param {boolean} [metadataOnly]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(collectionName, documentId, metadataOnly, options) {
            return localVarFp.getDocument(collectionName, documentId, metadataOnly, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get schema of collection
         * @param {string} collectionName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(collectionName, options) {
            return localVarFp.getSchema(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Login
         * @param {LoginDto} loginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto, options) {
            return localVarFp.login(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run multiple DSL queries in a single request
         * @param {string} collectionName
         * @param {any} body
         * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        msearch(collectionName, body, source, options) {
            return localVarFp.msearch(collectionName, body, source, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(options) {
            return localVarFp.resetPassword(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update documents that match a query using a script
         * @param {string} collectionName
         * @param {UpdateByQuery} updateByQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByQuery(collectionName, updateByQuery, options) {
            return localVarFp.updateByQuery(collectionName, updateByQuery, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update document by Id in the collection
         * @param {string} collectionName
         * @param {Document} document
         * @param {boolean} [partialUpdate]
         * @param {boolean} [docAsUpsert]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(collectionName, document, partialUpdate, docAsUpsert, options) {
            return localVarFp.updateDocument(collectionName, document, partialUpdate, docAsUpsert, options).then((request) => request(axios, basePath));
        },
    };
};
exports.HyperspaceApiFactory = HyperspaceApiFactory;
/**
 * HyperspaceApi - object-oriented interface
 * @export
 * @class HyperspaceApi
 * @extends {BaseAPI}
 */
class HyperspaceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add a new batch to the collection
     * @param {string} collectionName
     * @param {Array<Document>} document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    addBatch(collectionName, document, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).addBatch(collectionName, document, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a new document to the collection
     * @param {string} collectionName
     * @param {Document} document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    addDocument(collectionName, document, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).addDocument(collectionName, document, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Process bulk operations on documents
     * @param {string} collectionName
     * @param {Array<Document>} document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    bulk(collectionName, document, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).bulk(collectionName, document, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Clear all collection vectors
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    clearCollection(collectionName, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).clearCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the information of all the collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    collectionsInfo(options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).collectionsInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Commit
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    commit(collectionName, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).commit(collectionName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new collection
     * @param {string} collectionName
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    createCollection(collectionName, body, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).createCollection(collectionName, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes documents that match the specified query.
     * @param {string} collectionName
     * @param {DeleteByQueryRequest} deleteByQueryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    deleteByQuery(collectionName, deleteByQueryRequest, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).deleteByQuery(collectionName, deleteByQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a collection
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    deleteCollection(collectionName, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).deleteCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete document by Id
     * @param {string} collectionName
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    deleteDocument(collectionName, documentId, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).deleteDocument(collectionName, documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
     * @param {string} collectionName
     * @param {any} body
     * @param {string} [_options]
     * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    dslSearch(collectionName, body, _options, source, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).dslSearch(collectionName, body, _options, source, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Find document by Id
     * @param {string} collectionName
     * @param {string} documentId
     * @param {boolean} [metadataOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    getDocument(collectionName, documentId, metadataOnly, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).getDocument(collectionName, documentId, metadataOnly, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get schema of collection
     * @param {string} collectionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    getSchema(collectionName, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).getSchema(collectionName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Login
     * @param {LoginDto} loginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    login(loginDto, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).login(loginDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run multiple DSL queries in a single request
     * @param {string} collectionName
     * @param {any} body
     * @param {boolean} [source] Indicates whether source fields are returned for matching documents.These fields are returned in the hits._source property of the search response.Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    msearch(collectionName, body, source, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).msearch(collectionName, body, source, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reset password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    resetPassword(options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).resetPassword(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update documents that match a query using a script
     * @param {string} collectionName
     * @param {UpdateByQuery} updateByQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    updateByQuery(collectionName, updateByQuery, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).updateByQuery(collectionName, updateByQuery, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update document by Id in the collection
     * @param {string} collectionName
     * @param {Document} document
     * @param {boolean} [partialUpdate]
     * @param {boolean} [docAsUpsert]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    updateDocument(collectionName, document, partialUpdate, docAsUpsert, options) {
        return (0, exports.HyperspaceApiFp)(this.configuration).updateDocument(collectionName, document, partialUpdate, docAsUpsert, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HyperspaceApi = HyperspaceApi;
