/* tslint:disable */
/* eslint-disable */
/**
 * Vector Similarity Demo
 * The test functionality and Query testing
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@hyper-space.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthDto
 */
export interface AuthDto {
    /**
     * 
     * @type {string}
     * @memberof AuthDto
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Script
 */
export interface Script {
    /**
     * A string with the contents of the script.
     * @type {string}
     * @memberof Script
     */
    'source': string;
    /**
     * Scripting language.
     * @type {string}
     * @memberof Script
     */
    'lang'?: string;
    /**
     * Parameters passed to the script.
     * @type {{ [key: string]: any; }}
     * @memberof Script
     */
    'params'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface StatusDto
 */
export interface StatusDto {
    /**
     * Short status text
     * @type {string}
     * @memberof StatusDto
     */
    'status'?: string;
    /**
     * Status code
     * @type {number}
     * @memberof StatusDto
     */
    'code'?: number;
    /**
     * Verbose message
     * @type {string}
     * @memberof StatusDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateByQuery
 */
export interface UpdateByQuery {
    /**
     * 
     * @type {any}
     * @memberof UpdateByQuery
     */
    'query': any;
    /**
     * 
     * @type {Script}
     * @memberof UpdateByQuery
     */
    'script': Script;
}

/**
 * HyperspaceApi - axios parameter creator
 * @export
 */
export const HyperspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new batch to the collection
         * @param {string} collectionName 
         * @param {Array<Document>} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatch: async (collectionName: string, document: Array<Document>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('addBatch', 'collectionName', collectionName)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('addBatch', 'document', document)
            const localVarPath = `/api/v1/{collectionName}/batch`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = document

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new document to the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument: async (collectionName: string, document: Document, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('addDocument', 'collectionName', collectionName)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('addDocument', 'document', document)
            const localVarPath = `/api/v1/{collectionName}/document/add`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = document

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear all collection vectors
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCollection: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('clearCollection', 'collectionName', collectionName)
            const localVarPath = `/api/v1/{collectionName}/delete`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/collectionsInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Commit
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('commit', 'collectionName', collectionName)
            const localVarPath = `/api/v1/{collectionName}/commit`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new collection
         * @param {string} collectionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (collectionName: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('createCollection', 'collectionName', collectionName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCollection', 'body', body)
            const localVarPath = `/api/v1/collection/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteCollection', 'collectionName', collectionName)
            const localVarPath = `/api/v1/collection/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (collectionName: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteDocument', 'collectionName', collectionName)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('deleteDocument', 'documentId', documentId)
            const localVarPath = `/api/v1/{collectionName}/document/delete`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete function by name
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunction: async (collectionName: string, functionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteFunction', 'collectionName', collectionName)
            // verify required parameter 'functionName' is not null or undefined
            assertParamExists('deleteFunction', 'functionName', functionName)
            const localVarPath = `/api/v1/{collectionName}/function/delete/{functionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"functionName"}}`, encodeURIComponent(String(functionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dslSearch: async (collectionName: string, size: number, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('dslSearch', 'collectionName', collectionName)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('dslSearch', 'size', size)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('dslSearch', 'body', body)
            const localVarPath = `/api/v1/{collectionName}/dsl_search`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {boolean} [metadataOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: async (collectionName: string, documentId: string, metadataOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getDocument', 'collectionName', collectionName)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocument', 'documentId', documentId)
            const localVarPath = `/api/v1/{collectionName}/document/get`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }

            if (metadataOnly !== undefined) {
                localVarQueryParameter['metadata_only'] = metadataOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunction: async (collectionName: string, functionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getFunction', 'collectionName', collectionName)
            // verify required parameter 'functionName' is not null or undefined
            assertParamExists('getFunction', 'functionName', functionName)
            const localVarPath = `/api/v1/{collectionName}/function/{functionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"functionName"}}`, encodeURIComponent(String(functionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get schema of collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (collectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getSchema', 'collectionName', collectionName)
            const localVarPath = `/api/v1/{collectionName}/schema`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('login', 'loginDto', loginDto)
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reset_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset according to the selected search option.
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {string} [functionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (collectionName: string, size: number, body: any, functionName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('search', 'collectionName', collectionName)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('search', 'size', size)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('search', 'body', body)
            const localVarPath = `/api/v1/{collectionName}/search`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (functionName !== undefined) {
                localVarQueryParameter['functionName'] = functionName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFunction: async (collectionName: string, functionName: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('setFunction', 'collectionName', collectionName)
            // verify required parameter 'functionName' is not null or undefined
            assertParamExists('setFunction', 'functionName', functionName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('setFunction', 'body', body)
            const localVarPath = `/api/v1/{collectionName}/function/{functionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"functionName"}}`, encodeURIComponent(String(functionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update documents that match a query using a script
         * @param {string} collectionName 
         * @param {UpdateByQuery} updateByQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByQuery: async (collectionName: string, updateByQuery: UpdateByQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateByQuery', 'collectionName', collectionName)
            // verify required parameter 'updateByQuery' is not null or undefined
            assertParamExists('updateByQuery', 'updateByQuery', updateByQuery)
            const localVarPath = `/api/v1/{collectionName}/document/update_by_query`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateByQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update document by Id in the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {boolean} [partialUpdate] 
         * @param {boolean} [docAsUpsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument: async (collectionName: string, document: Document, partialUpdate?: boolean, docAsUpsert?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateDocument', 'collectionName', collectionName)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('updateDocument', 'document', document)
            const localVarPath = `/api/v1/{collectionName}/document/update`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partialUpdate !== undefined) {
                localVarQueryParameter['partialUpdate'] = partialUpdate;
            }

            if (docAsUpsert !== undefined) {
                localVarQueryParameter['docAsUpsert'] = docAsUpsert;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/msgpack';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = document

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HyperspaceApi - functional programming interface
 * @export
 */
export const HyperspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HyperspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new batch to the collection
         * @param {string} collectionName 
         * @param {Array<Document>} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBatch(collectionName: string, document: Array<Document>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBatch(collectionName, document, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.addBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new document to the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDocument(collectionName: string, document: Document, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDocument(collectionName, document, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.addDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear all collection vectors
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearCollection(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearCollection(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.clearCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.collectionsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Commit
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commit(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commit(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.commit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new collection
         * @param {string} collectionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(collectionName: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(collectionName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.createCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.deleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(collectionName: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(collectionName, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.deleteDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete function by name
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFunction(collectionName: string, functionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFunction(collectionName, functionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.deleteFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dslSearch(collectionName: string, size: number, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dslSearch(collectionName, size, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.dslSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {boolean} [metadataOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocument(collectionName: string, documentId: string, metadataOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(collectionName, documentId, metadataOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.getDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunction(collectionName: string, functionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunction(collectionName, functionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.getFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get schema of collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(collectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(collectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.getSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset according to the selected search option.
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {string} [functionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(collectionName: string, size: number, body: any, functionName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(collectionName, size, body, functionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFunction(collectionName: string, functionName: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFunction(collectionName, functionName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.setFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update documents that match a query using a script
         * @param {string} collectionName 
         * @param {UpdateByQuery} updateByQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateByQuery(collectionName: string, updateByQuery: UpdateByQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateByQuery(collectionName, updateByQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.updateByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update document by Id in the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {boolean} [partialUpdate] 
         * @param {boolean} [docAsUpsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocument(collectionName: string, document: Document, partialUpdate?: boolean, docAsUpsert?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocument(collectionName, document, partialUpdate, docAsUpsert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HyperspaceApi.updateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HyperspaceApi - factory interface
 * @export
 */
export const HyperspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HyperspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new batch to the collection
         * @param {string} collectionName 
         * @param {Array<Document>} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatch(collectionName: string, document: Array<Document>, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.addBatch(collectionName, document, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new document to the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(collectionName: string, document: Document, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.addDocument(collectionName, document, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear all collection vectors
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCollection(collectionName: string, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.clearCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the information of all the collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsInfo(options?: any): AxiosPromise<any> {
            return localVarFp.collectionsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Commit
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(collectionName: string, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.commit(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new collection
         * @param {string} collectionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(collectionName: string, body: any, options?: any): AxiosPromise<any> {
            return localVarFp.createCollection(collectionName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName: string, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.deleteCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(collectionName: string, documentId: string, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.deleteDocument(collectionName, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete function by name
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunction(collectionName: string, functionName: string, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.deleteFunction(collectionName, functionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dslSearch(collectionName: string, size: number, body: any, options?: any): AxiosPromise<any> {
            return localVarFp.dslSearch(collectionName, size, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find document by Id
         * @param {string} collectionName 
         * @param {string} documentId 
         * @param {boolean} [metadataOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(collectionName: string, documentId: string, metadataOnly?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.getDocument(collectionName, documentId, metadataOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunction(collectionName: string, functionName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFunction(collectionName, functionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get schema of collection
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(collectionName: string, options?: any): AxiosPromise<any> {
            return localVarFp.getSchema(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: any): AxiosPromise<AuthDto> {
            return localVarFp.login(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(options?: any): AxiosPromise<string> {
            return localVarFp.resetPassword(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find top X similar documents in the dataset according to the selected search option.
         * @param {string} collectionName 
         * @param {number} size 
         * @param {any} body 
         * @param {string} [functionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(collectionName: string, size: number, body: any, functionName?: string, options?: any): AxiosPromise<any> {
            return localVarFp.search(collectionName, size, body, functionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Function
         * @param {string} collectionName 
         * @param {string} functionName 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFunction(collectionName: string, functionName: string, body: any, options?: any): AxiosPromise<StatusDto> {
            return localVarFp.setFunction(collectionName, functionName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update documents that match a query using a script
         * @param {string} collectionName 
         * @param {UpdateByQuery} updateByQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByQuery(collectionName: string, updateByQuery: UpdateByQuery, options?: any): AxiosPromise<string> {
            return localVarFp.updateByQuery(collectionName, updateByQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update document by Id in the collection
         * @param {string} collectionName 
         * @param {Document} document 
         * @param {boolean} [partialUpdate] 
         * @param {boolean} [docAsUpsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(collectionName: string, document: Document, partialUpdate?: boolean, docAsUpsert?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updateDocument(collectionName, document, partialUpdate, docAsUpsert, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HyperspaceApi - object-oriented interface
 * @export
 * @class HyperspaceApi
 * @extends {BaseAPI}
 */
export class HyperspaceApi extends BaseAPI {
    /**
     * 
     * @summary Add a new batch to the collection
     * @param {string} collectionName 
     * @param {Array<Document>} document 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public addBatch(collectionName: string, document: Array<Document>, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).addBatch(collectionName, document, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new document to the collection
     * @param {string} collectionName 
     * @param {Document} document 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public addDocument(collectionName: string, document: Document, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).addDocument(collectionName, document, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear all collection vectors
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public clearCollection(collectionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).clearCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the information of all the collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public collectionsInfo(options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).collectionsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Commit
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public commit(collectionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).commit(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new collection
     * @param {string} collectionName 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public createCollection(collectionName: string, body: any, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).createCollection(collectionName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a collection
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public deleteCollection(collectionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).deleteCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete document by Id
     * @param {string} collectionName 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public deleteDocument(collectionName: string, documentId: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).deleteDocument(collectionName, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete function by name
     * @param {string} collectionName 
     * @param {string} functionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public deleteFunction(collectionName: string, functionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).deleteFunction(collectionName, functionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find top X similar documents in the dataset using Elasticsearch DSL query
     * @param {string} collectionName 
     * @param {number} size 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public dslSearch(collectionName: string, size: number, body: any, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).dslSearch(collectionName, size, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find document by Id
     * @param {string} collectionName 
     * @param {string} documentId 
     * @param {boolean} [metadataOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public getDocument(collectionName: string, documentId: string, metadataOnly?: boolean, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).getDocument(collectionName, documentId, metadataOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Function
     * @param {string} collectionName 
     * @param {string} functionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public getFunction(collectionName: string, functionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).getFunction(collectionName, functionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get schema of collection
     * @param {string} collectionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public getSchema(collectionName: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).getSchema(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public login(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).login(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public resetPassword(options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).resetPassword(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find top X similar documents in the dataset according to the selected search option.
     * @param {string} collectionName 
     * @param {number} size 
     * @param {any} body 
     * @param {string} [functionName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public search(collectionName: string, size: number, body: any, functionName?: string, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).search(collectionName, size, body, functionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Function
     * @param {string} collectionName 
     * @param {string} functionName 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public setFunction(collectionName: string, functionName: string, body: any, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).setFunction(collectionName, functionName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update documents that match a query using a script
     * @param {string} collectionName 
     * @param {UpdateByQuery} updateByQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public updateByQuery(collectionName: string, updateByQuery: UpdateByQuery, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).updateByQuery(collectionName, updateByQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update document by Id in the collection
     * @param {string} collectionName 
     * @param {Document} document 
     * @param {boolean} [partialUpdate] 
     * @param {boolean} [docAsUpsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HyperspaceApi
     */
    public updateDocument(collectionName: string, document: Document, partialUpdate?: boolean, docAsUpsert?: boolean, options?: RawAxiosRequestConfig) {
        return HyperspaceApiFp(this.configuration).updateDocument(collectionName, document, partialUpdate, docAsUpsert, options).then((request) => request(this.axios, this.basePath));
    }
}



